#!/usr/bin/env python
# coding: utf-8

# <div class="alert alert-success">
# <b>Комментарий ревьюера v 3.0 ✔️:</b> Отлично, Сергей! Ты здорово поработал над комментариями и теперь твой проект принят.
#     
# Спасибо за работу и успехов в следующих проектах!)

# <div class="alert alert-danger">
# <b>Комментарий ревьюера v 2.0 ❌:</b> Сергей, ты хорошо поработал над комментариями, но все же у меня осталось еще одно замечание, оно отмечено v 2.0 и красным цветом. Пожалуйста, исправь его и я буду рад принять твой проект)

# <div style="border:solid green 2px; padding: 20px">
# <b>Привет!</b>
# 
# Меня зовут Михаленко Дмитрий, и я буду проверять твой проект. Предлагаю общаться на «ты» :) Но если это не удобно - дай знать, и мы перейдем на "вы". 
# 
# Моя основная цель — не указать на совершенные тобою ошибки, а поделиться своим опытом и помочь тебе стать аналитиком данных. Ты уже проделал большую работу над проектом, но давай сделаем его еще лучше. Ниже ты найдешь мои комментарии - **пожалуйста, не перемещай, не изменяй и не удаляй их**. Увидев у тебя ошибку, в первый раз я лишь укажу на ее наличие и дам тебе возможность самому найти и исправить ее. На реальной работе твой начальник будет поступать так же, а я пытаюсь подготовить тебя именно к работе аналитиком. Но если ты пока не справишься с такой задачей - при следующей проверке я дам более точную подсказку. Я буду использовать цветовую разметку:
# 
# <div class="alert alert-danger">
# <b>Комментарий ревьюера ❌:</b> Так выделены самые важные замечания. Без их отработки проект не будет принят. </div>
# 
# <div class="alert alert-warning">
# <b>Комментарий ревьюера ⚠️:</b> Так выделены небольшие замечания. Я надеюсь, что их ты тоже учтешь - твой проект от этого станет только лучше. Но настаивать на их отработке не буду.
# 
# </div>
# 
# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Так я выделяю все остальные комментарии.</div>
# 
# Давай работать над проектом в диалоге: **если ты что-то меняешь в проекте или отвечаешь на мои комментарии — пиши об этом.** Мне будет легче отследить изменения, если ты выделишь свои комментарии:
# <div class="alert alert-info"> <b>Комментарий студента:</b> Например, вот так.</div>
# 
# Всё это поможет выполнить повторную проверку твоего проекта оперативнее. 

# # Исследование объявлений о продаже квартир
# 
# В вашем распоряжении данные сервиса Яндекс.Недвижимость — архив объявлений о продаже квартир в Санкт-Петербурге и соседних населённых пунктов за несколько лет. Нужно научиться определять рыночную стоимость объектов недвижимости. Ваша задача — установить параметры. Это позволит построить автоматизированную систему: она отследит аномалии и мошенническую деятельность. 
# 
# По каждой квартире на продажу доступны два вида данных. Первые вписаны пользователем, вторые — получены автоматически на основе картографических данных. Например, расстояние до центра, аэропорта, ближайшего парка и водоёма. 

# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Объёмная и творческая аналитическая задача, тем интереснее будет с ней справиться! </div>

# ### Откройте файл с данными и изучите общую информацию. 

# In[1]:


import pandas as pd
import matplotlib.pyplot as plt
get_ipython().run_line_magic('matplotlib', 'inline')
import seaborn as sns
sns.set()
pd.options.display.float_format = '{:,.2f}'.format
pd.options.display.max_columns = 100
data=pd.read_csv('/datasets/real_estate_data.csv', sep='\t')
data.info()


# Приводим название столбца 'cityCenters_nearest' к "Змеиному регистру" и выводим чтобы проверить.

# In[2]:


data = data.rename(columns={"cityCenters_nearest" : "city_centers_nearest"})


# In[3]:


data.head(5)


# In[4]:


data.hist(bins=20, figsize=(15,20)) #параметр bins вызван так как в некоторых гистограммах данные отображались очень не точно


# In[5]:


#выясним есть ли дубликаты
print('Количество дубликатов:', data.duplicated().sum())


# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Хорошее начало, так держать. </div>

# ### Предобработка данных

# In[6]:


#округляем до целых чисел стоимость недвижимости
data['last_price'] = data['last_price'].astype(int)
#форматируем значение даты размещения объявления
data['first_day_exposition'] = pd.to_datetime(data['first_day_exposition'], format='%Y-%m-%dT%H:%M:%S')


# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Эти типы данных подходят им лучше. </div>

# In[7]:


data.isna().sum()


# Возможные причины пропуска данных:
# 1. celing_height скорее всего не измерена высота потолка. Можно принять медианное значение или среднее в 2,7 метра.
# 2. floors_total заполним данные тем же этажом что и сам объект. Столько этажей точно есть в этом здании.
# 3. living_area заменим медианным значением.
# 4. is_apartment там где данные не заполнены заменим на значение False.(Не апартаменты)
# 5. kitchen_area Заменим медианным значением.
# 6. balcony пропуск из-за того что его нет в квартире. Заменим на 0.
# 7. locality_name пропуски в небольшом количестве. Удалим данные с пропусками.
# 8. airport_nearest по большей части пропущены значения на удаленности больше 30 км от аэропорта(проверил несколько значений по карте)
# 9. city_centers_arround3000, ponds_arround3000, park_arround3000 Примем что их нет в радиусе 3 километров и заменим значения на 0.
# 10. В park_nearest и pond_nearest значения пропущены в объектах расположенных в пригороде или поселках в далеке от известных парков и городских центров.
# 11. days_exposition-колличество дней от размещения объявления до продажи не определено, т.к. скорее всего квартира еще не продана 

# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Согласен с такми решениями по данным, отлично! </div>

# In[8]:


#заполним пропущенные значение медианой
data['ceiling_height'] = data['ceiling_height'].fillna(data['ceiling_height'].median())


# In[9]:


#Заполним пропущенные значения этажности зданий значением этажа самого объекта недвижимости. Плюс приведем значения к int
data['floors_total'] = data['floors_total'].fillna(data['floor'])
data['floors_total'] = data['floors_total'].astype('int')


# In[10]:


#Заполним пропуски в living_area и kitchen_area медианным значением
data['living_area'] = data['living_area'].fillna(data['living_area'].median())
data['kitchen_area'] = data['kitchen_area'].fillna(data['kitchen_area'].median())


# In[11]:


#Примем что в пропусках-не апартаменты
data['is_apartment'] = data['is_apartment'].fillna(False)


# In[12]:


#Заменим пропуски в balcony на 0 и приведем к типу int
data['balcony'] = data['balcony'].fillna(0)
data['balcony'] = data['balcony'].astype(int)


# In[13]:


#Удалим строки с пропусками в столбце locality_name
data.dropna(subset = ['locality_name'], inplace = True)


# In[14]:


#Заменим пропуски по прудам и паркам на 0
data['parks_around3000'] = data['parks_around3000'].fillna(0)
data['ponds_around3000'] = data['ponds_around3000'].fillna(0)


# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Верно выполняешь заполнения и дроп ненужных данных. </div>

# In[15]:


#Проверим сколько пропусков осталось
data.isna().sum()


# In[16]:


data.head(5)


# In[17]:


data['locality_name'].unique()
data = data.replace('посёлок Пансионат Зелёный Бор', 'поселок Пансионат Зелёный Бор')


# <div class="alert alert-danger">
# <b>Комментарий ревьюера ❌:</b> На самом деле разное написание "е-ё" встречается в названиях гораздо чаще, чем в этом названии, так что тут логичнее привести все варианты к одному виду (лучше и логичнее "е")

# In[18]:


data['locality_name'].sort_values().unique()


# <div class="alert alert-danger">
# <b>Комментарий ревьюера v 2.0 ❌:</b> Повторюсь, <b>все</b> названия, посмотри например городской поселок Янино-1 может быть написан как через е, так и через ё, поэтому тут логично сразу одной строкой привести все написания к одному стилю

# In[19]:


data['locality_name'] = data['locality_name'].str.replace('ё', 'е')
data['locality_name'].sort_values().unique()


# <div class="alert alert-info"> V 2.0 Исправил. С первого раза не понял)

# <div class="alert alert-success">
# <b>Комментарий ревьюера v 3.0 ✔️:</b> Супер, сейчас все очевидные неявные дубликаты устранены

# <div class="alert alert-warning">
# <b>Комментарий ревьюера ⚠️:</b> Еще в days_exposition неплохо было бы посмотреть на пропуски по годам, вдруг так можно увидеть какую-то закономерность

# <div class="alert alert-info"> Наибольшее количество пропусков наблюдается в объявлениях от 2019 года. Самых свежих. Значит гипотеза о том, что пропущеные значения это не проданные квартиры вполне возможна. (Сам код отоюражен ниже, после добавления столбцов по году)

# <div class="alert alert-success">
# <b>Комментарий ревьюера v 2.0 ✔️:</b> Всё логично

# In[20]:


# Функция для подсчёта границ с учетом 1.5 размаха
def quartile_range(df, column):
    q1 = df[column].quantile(0.25)
    q3 = df[column].quantile(0.75)
    iqr = q3 - q1
    dfq = df.loc[(df[column] < q3 + 1.5*iqr) & (df[column] > q1 - 1.5*iqr), column]
    return dfq
# Столбцы с выбросами
list_features = ['last_price', 'total_area', 'kitchen_area', 'living_area', 'days_exposition', 'ceiling_height', 'rooms']
for col in list_features:
    data[col] = quartile_range(data, col)

# Возвращаем в целочисленный тип число комнат
data['rooms'] = data['rooms'].fillna(0).astype(int)

# Изучаем, есть ли выбивающиеся значения
data.describe()


# <div class="alert alert-danger">
# <b>Комментарий ревьюера ❌:</b> Хороший способ фильтрации, но посмотри чуть внимательнее на нижнюю границу цены, кажется она не попала в фильтр и ее нужно обработать вручную

# In[21]:


print(data['last_price'].sort_values(ascending=True))

data = data.drop(axis=0, index=8793)
print(data['last_price'].sort_values(ascending=True))


# <div class="alert alert-info"> Исправил

# <div class="alert alert-success">
# <b>Комментарий ревьюера v 2.0 ✔️:</b>Молодец!

# <div class="alert alert-danger">
# <b>Комментарий ревьюера ❌:</b> Также, в разделе "Предобработка данных" было проведено довольно много анализа и работы, все же стоит написать по нему хотя бы короткий вывод

# ##### Выводы

# - Медианная высота потолков 2.65 метра
# - Максимальная стоимость квартиры составляет почти 12 милионов
# - По столбцу 'is_apartment' почти для всех квартир данные были не заполнены
# - Было довольно много выбросов, от которых успешно избавились
# - Наибольшее количество пропусков наблюдается в объявлениях от 2019 года. Самых свежих. Значит гипотеза о том, что пропущеные значения это не проданные квартиры вполне возможна.

# <div class="alert alert-success">
# <b>Комментарий ревьюера v 2.0 ✔️:</b> Так раздел стал еще целостнее

# ### Посчитайте и добавьте в таблицу новые столбцы

# In[22]:


#Добавляем следующие столбцы:
# Цена одного квадратного метра:
data['meter_price'] = (data['last_price']/data['total_area'])


# In[23]:


#Дни недели, месяца, года
data['day_week'] = data['first_day_exposition'].dt.weekday
data['month'] = data['first_day_exposition'].dt.month
data['year'] = data['first_day_exposition'].dt.year


# In[24]:


#Тип этажа квартиры
def floor_set(row):
    
    if row['floor'] == 1:
        return 'первый'
    if row['floor'] == row['floors_total']:
        return 'последний'
    else:
        return 'другой'
    
data['floor_type'] = data.apply(floor_set, axis = 1)


# In[25]:


# Расстояние до центра города
data['city_center_length'] = round((data['city_centers_nearest']/1000)).astype(int, errors = 'ignore')


# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Великолепно, все пункты задания выполнены в полном объёме

# In[26]:


data[data['days_exposition'].isna()].groupby('year')['month'].count()


# <div class="alert alert-info"> **ВОТ ОН**

# <div class="alert alert-success">
# <b>Комментарий ревьюера v 2.0 ✔️:</b> Хорошо)

# In[27]:


#Заменим пропуски на 9999 чтобы потом легче было посчитать
data['days_exposition'] = data['days_exposition'].fillna(9999)


# ### Проведите исследовательский анализ данных

# #### Изучаем общую площадь

# In[28]:


plt.hist(data['total_area'], bins=40, range=(10,200))
plt.title('Общая площадь')
plt.xlabel('М2')
plt.ylabel('Колличество квартир')
plt.show()
print('Квартиры с максимальной общей площадью:')
print(data['total_area'].sort_values(ascending=False).head(5))


# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Хорошо и последовательно строишь необходимые гистограммы одну за одной

# <div class="alert alert-warning">
# <b>Комментарий ревьюера ⚠️:</b> Могу посоветовать посмотреть данные материалы, чтобы научиться оформлять графики еще лучше:
# 
# [Здесь](https://pyprog.pro/mpl/mpl_title.html)
#   
# [И здесь](https://pyprog.pro/mpl/mpl_axis_signatures.html)
#     
# [И вот тут](https://www.python-graph-gallery.com)
#     
#    

# #### Изучаем жилую площадь

# In[29]:


plt.hist(data['living_area'], bins=40, range=(10,130))
plt.title('Жилая площадь')
plt.xlabel('М2')
plt.ylabel('Колличество квартир')
plt.show()
print('Квартиры с максимальной жилой площадью:')
print(data['total_area'].sort_values(ascending=False).head(5))


# #### Изучаем площадь кухни

# In[30]:


plt.hist(data['kitchen_area'], bins=40, range=(3,50))
plt.title('Площадь кухни')
plt.xlabel('М2')
plt.ylabel('Колличество квартир')
plt.show()
print('Квартиры с максимальной площадью кухни:')
print(data['total_area'].sort_values(ascending=False).head(5))


# Подавляющее большинство квартир имеют площадь кухни до 10 квадратных метров.

# #### Изучаем цену квартир

# In[31]:


plt.hist(data['last_price'], bins=50, range=(10,23000000))
plt.title('Цена объекта')
plt.xlabel('Цена объекта в рублях')
plt.ylabel('Колличество квартир')
plt.show()
print('Квартиры с максимальной ценой:')
print(data['last_price'].sort_values(ascending=False).head(5))


# #### Изучим количество комнат

# In[32]:


plt.hist(data['rooms'], bins=10, range=(0,10))
plt.title('Количество комнат')
plt.xlabel('Комнаты')
plt.ylabel('Колличество квартир')
plt.show()
print('Квартиры с максимальной количеством комнат:')
print(data['rooms'].sort_values(ascending=False).head(5))


# #### Изучим высоту потолков в квартирах

# In[33]:


plt.hist(data.query('(ceiling_height > 2) & (ceiling_height < 4)')['ceiling_height'], bins=8)
plt.title('Высота потолков')
plt.xlabel('Метры')
plt.ylabel('Количество квартир')
plt.show()
print('Квартиры с максимальной высотой потолка:')
print(data['rooms'].sort_values(ascending=False).head(5))


# #### Изучаем этаж и тип этажа

# In[34]:


plt.hist(data['floor'], bins=35, range=(0,35))
plt.title('Объекты по этажам')
plt.xlabel('Номера этажей')
plt.ylabel('Колличество квартир')
plt.show()
print('Квартиры на максимально высоких этажах:')
print(data['floor'].sort_values(ascending=False).head(5))


# In[35]:


plt.hist(data['floor_type'], bins=3, range=(0,3))
plt.title('Объекты по типам этажей')
plt.xlabel('Тип этажей')
plt.ylabel('Колличество квартир')
plt.show()
print('Количество квартир по типам этажей')
print(data.groupby('floor_type')['floor'].count())


# #### Изучим обoщее колличество этажей в доме

# In[36]:


plt.hist(data['floors_total'], bins=30, range=(0,30))
plt.title('Общее количество этажей')
plt.xlabel('Этажность дома')
plt.ylabel('Колличество квартир')
plt.show()
print('Самые высокие дома из подборки')
print(data['floor'].sort_values(ascending=False).head(5))


# #### Изучим расстояние до ближайшего аэропорта

# In[37]:


plt.hist(data['airports_nearest'], bins=30, range=(0,80000))
plt.title('Удаленность от аэропорта')
plt.xlabel('Метры')
plt.ylabel('Колличество квартир')
plt.show()
print('Самые близкие к аэропорту')
print(data['airports_nearest'].sort_values(ascending=True).head(5))


# #### Изучим расстояние до ближайшего парка

# In[38]:


plt.hist(data['parks_nearest'], bins=30, range=(0,2000))
plt.title('Удаленность от парка')
plt.xlabel('Метры')
plt.ylabel('Колличество квартир')
plt.show()
print('Самые близкие к паркам')
print(data['parks_nearest'].sort_values(ascending=True).head(5))


# #### Изучим дни и месяцы публикации объяления

# In[39]:


plt.hist(data['day_week'], bins=7, range=(0,6))
plt.title('День публикации объявления')
plt.xlabel('День недели')
plt.ylabel('Колличество квартир')
plt.show()
print('Колличество публикаций по дням')
print(data.groupby('day_week')['floor'].count())


# In[40]:


plt.hist(data['month'], bins=12, range=(0,12))
plt.title('Месяц публикации объявления')
plt.xlabel('Месяц')
plt.ylabel('Колличество квартир')
plt.show()
print('Колличество публикаций по месяцам')
print(data.groupby('month')['floor'].count())


# ##### Выводы

# - Большинство продающихся квартир с площадью около 50 метров.
# - Средняя высота потолка в квартирах 2.7 метра. Встречаются квартиры с высотой потолка в 5 метров, но очень редко.
# - Большинство квартир расположено на первых пяти этажах, т.к. в Санкт-Петербурге и окрестностях этажность зданий не высокая
# - Чаще размещают объявления где кваритры расположены не на первом и не на послежнем этажах, что не удивительно ведь так фактически гораздо больше
# - В объявлениях привалируют 5-ти и 10-ти этажные дома
# - Большинство квартир в объявлениях находятся в 20 километрах от аэропорта
# - В большинстве объявлений в 500 метрах от квартиры можно найти парк
# - Чаще всего объявления публикуются в будние дни
# - Наибольшее количество публикаций объявлений в декабре

# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Классно построил все графики и добавил понятное описание по пунктам, молодец!

# ### Изучим скорость продажи квартир

# In[41]:


plt.hist(data['days_exposition'], bins=100, range=(0,300))
plt.title('Скорость продажи квартир')
plt.xlabel('Дней от размещения до продажи')
plt.ylabel('Колличество квартир')
plt.show()


# In[42]:


print('Медианное время продажи квартиры:', (data.query('days_exposition != 9999')['days_exposition'].median()).astype(int), '\n')
print('Среднее время продажи квартиры:', (data.query('days_exposition != 9999')['days_exposition'].mean()).astype(int), '\n')


# In[43]:


print('Самые быстрые продажи')
print(data['days_exposition'].sort_values(ascending=True).head(5), '\n')
print('Параметры сроков продажи:','\n', (data.query('days_exposition != 9999')['days_exposition'].describe()).astype(int))


# #### Вывод

#     Медианное время продажи квартиры: 95, среднее время продажи квартиры: 180. Чаще всего квартиры продаются за 95 дней. Медленная продажа > 230 дней, быстрая продажа < 45 дней. 

# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Отлично, все границы days_exposition установлены

# ### Факторы непосредственно влияющие на стоимость квартир

# In[44]:


# Зависимость цены от общей площади
data.pivot_table(index = 'total_area', values = 'last_price').plot(grid = True, style = 'o', figsize = (5, 5), alpha = 0.5)
print('Кореляция цены и площади:', '\n')
print(data.pivot_table(index = 'month', values = ['total_area', 'last_price']).corr(),'\n')


# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Здорово, что анализируешь как линейную, так и нелинейную зависимость

# In[45]:


# Зависимость цены от жилой площади
data.pivot_table(index = 'living_area', values = 'last_price').plot(grid = True, style = 'o', figsize = (5, 5), alpha = 0.5)
print('Кореляция цены и жилой площади:', '\n')
print(data.pivot_table(index = 'month', values = ['living_area', 'last_price']).corr(),'\n')


# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> И диаграмма рассеяния это самый подходящий график для анализа зависимости от площади

# In[46]:


# Зависимость цены от площади кухни
data.pivot_table(index = 'kitchen_area', values = 'last_price').plot(grid = True, style = 'o', figsize = (5, 5), alpha = 0.5)
print('Кореляция цены и площади кухни:', '\n')
print(data.pivot_table(index = 'month', values = ['kitchen_area', 'last_price']).corr(),'\n')


# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Хорошо

# In[47]:


# Зависимость цены от колличества комнат
data.query('rooms > 0').pivot_table(index='rooms', values='last_price').plot(grid = True, style = 'o-', figsize = (5, 5))
print('Кореляция цены и площади кухни:', '\n')
print(data.pivot_table(index = 'month', values = ['rooms', 'last_price']).corr(),'\n')


# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> А тут и далее гораздо лучше смотрятся линейные графики по средним

# In[48]:


# Зависимость цены от типа этажа квартиры
data.pivot_table(index = 'floor_type', values = 'last_price').plot(grid = True, style = '-o', figsize = (5, 5))
print('Кореляция цены и площади кухни:', '\n')
print(data.pivot_table(index = 'month', values = ['rooms', 'last_price']).corr(),'\n')


# In[49]:


# Зависимость от даты размещения день недели
data.pivot_table(index = 'day_week', values = 'last_price').plot(grid = True, style = '-o', figsize = (5, 5))
print('Кореляция цены и размещения в день недели:', '\n')
print(data.pivot_table(index = 'month', values = ['day_week', 'last_price']).corr(),'\n')


# In[50]:


# Зависимость от даты размещения день месяц
data.pivot_table(index = 'month', values = 'last_price').plot(grid = True, style = '-o', figsize = (5, 5))
print('Кореляция цены и времени размещения по месяцу:', '\n')
print(data.pivot_table(index = 'day_week', values = ['month', 'last_price']).corr(),'\n')


# In[51]:


# Зависимость от даты размещения день год
data.pivot_table(index = 'year', values = 'last_price').plot(grid = True, style = '-o', figsize = (5, 5))
print('Кореляция цены и времени размещения по году:', '\n')
print(data.pivot_table(index = 'day_week', values = ['year', 'last_price']).corr(),'\n')


# ##### Выводы

# - Зависимость цены от площади прямая.
# - Зависимость цены от жилой площади чуть менее выражена, так же как и от площади  кухни но также прямая.
# - Летом цена в размещенных объявлениях ниже. (возможно из-за сезона отпусков и падения спроса)
# - В понедельник, вторник и среду, цена размещения объявлений маскимальна. (возможно изза того, что в понедльник объявления в свои рабочие дни размещают агентства недвижимости)
# - Квартиры расположеные на не первых и не последних этажах стоят дороже
# - Колличество комнат также влияет на цену, но меньше.
# - Самые дорогие квартиры в центре.

# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Замечательно, детально описал все зависимости!

# ### Расчет стоимости квадратного метра 10 населенных пунктов в которых наибольшее количество объявлений

# In[52]:


# Выявим 10 населенных пунктов по размещению объявлений
top_city = data.groupby('locality_name')['total_area'].count().sort_values(ascending=False).head(10)
print('10 населенных пунктов с наибольшим количеством объявлений:', '\n', top_city, '\n')

top_city_meter_price = (((data.query('locality_name in (@top_city.index)').pivot_table(values='meter_price', index='locality_name')).astype(int)).sort_values('meter_price', ascending = False))
print('Рейтинг населенных пунктов по цене квадратного метра:', '\n', top_city_meter_price)


# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Ты правильно ответил на вопрос задания!

# ### Расчет стоимости километра удаленности от центра города

# In[53]:


data['city_center_length'] = data['city_center_length'].fillna(value=0).astype(int)
data.query('locality_name == "Санкт-Петербург"').pivot_table(index='city_center_length', values='last_price').plot(grid=True, style='o-', xlim=(0,30), figsize=(10, 5), title='Средняя цена каждого километра')


# In[54]:


print('Корреляция цены и удалённости от центра:','\n')
print(data.pivot_table(index='floor', values=['city_center_length', 'last_price']).corr(),'\n')


# ##### Выводы

# Средняя стоимость километра удаленности от центра города указана на графике. Можно сделать вывод, что самми дорогими являются ближайшие 7 километров к центру города. Далее происходит резкое падение цены.

# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Средние цены по километрам также рассчитаны безупречно

# ### Общий вывод

# **Факторы влияющие на стоимость**
# 
# - Чем больше площадь квартиры тем она дороже. Количество комнат тоже влияет на стоимость но меньше. 
# - Квартиры расположенные на первом этаже продаются со значительным дисконтом.
# 
# **Стоимость квадратного метра 10 населенных пунктов в которых наибольшее количество объявлений**
# - Как и ожидалось самый дорогой квадратных метр в Санкт-Петербурге-105684
# - Следующим по стоимости идет Пушки-100462
# 
# **Стоимость квартир в зависимости от удаленности от центра**
# - Самыми дорогими являются ближайшие 7 километров к центру города. Далее происходит резкое падение цены.
# 
# **Скорость продажи квартир**
# - Медианное время продажи квартиры: 95, среднее время продажи квартиры: 180. 
# - Чаще всего квартиры продаются за 95 дней. Медленная продажа > 230 дней, быстрая продажа < 45 дней
# 

# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Супер, подробные и хорошие выводы

# <div class="alert alert-success">
# <b>Комментарий ревьюера ✔️:</b> Сергей, проект отличный! У тебя очень сильные аналитические навыки и владение инструментами для проведения исследования. Но всё же в проекте есть несколько замечаний и я попрошу тебя исправить их, чтобы он стал еще лучше! </div>

# **Чек-лист готовности проекта**
# 
# Поставьте 'x' в выполненных пунктах. Далее нажмите Shift+Enter.

# - [x]  открыт файл
# - [x]  файлы изучены (выведены первые строки, метод `info()`, гистограммы и т.д.)
# - [x]  определены пропущенные значения
# - [x]  заполнены пропущенные значения там, где это возможно
# - [x]  есть пояснение, какие пропущенные значения обнаружены
# - [x]  изменены типы данных
# - [x]  есть пояснение, в каких столбцах изменены типы и почему
# - [x]  устранены неявные дубликаты в названиях населённых пунктов
# - [x]  устранены редкие и выбивающиеся значения (аномалии) во всех столбцах
# - [x]  посчитано и добавлено в таблицу: цена одного квадратного метра
# - [x]  посчитано и добавлено в таблицу: день публикации объявления (0 - понедельник, 1 - вторник и т.д.)
# - [x]  посчитано и добавлено в таблицу: месяц публикации объявления
# - [x]  посчитано и добавлено в таблицу: год публикации объявления
# - [x]  посчитано и добавлено в таблицу: тип этажа квартиры (значения — «первый», «последний», «другой»)
# - [x]  посчитано и добавлено в таблицу: расстояние в км до центра города
# - [x]  изучены и описаны следующие параметры:
#         - общая площадь;
#         - жилая площадь;
#         - площадь кухни;
#         - цена объекта;
#         - количество комнат;
#         - высота потолков;
#         - этаж квартиры;
#         - тип этажа квартиры («первый», «последний», «другой»);
#         - общее количество этажей в доме;
#         - расстояние до центра города в метрах;
#         - расстояние до ближайшего аэропорта;
#         - расстояние до ближайшего парка;
#         - день и месяц публикации объявления
# - [x]  построены гистограммы для каждого параметра
# - [x]  выполнено задание: "Изучите, как быстро продавались квартиры (столбец days_exposition). Этот параметр показывает, сколько дней «висело» каждое объявление.
#     - Постройте гистограмму.
#     - Посчитайте среднее и медиану.
#     - В ячейке типа markdown опишите, сколько обычно занимает продажа. Какие продажи можно считать быстрыми, а какие — необычно долгими?"
# - [x]  выполнено задание: "Какие факторы больше всего влияют на общую (полную) стоимость объекта? Постройте графики, которые покажут зависимость цены от указанных ниже параметров. Для подготовки данных перед визуализацией вы можете использовать сводные таблицы."
#         - общей площади;
#         - жилой площади;
#         - площади кухни;
#         - количество комнат;
#         - типа этажа, на котором расположена квартира (первый, последний, другой);
#         - даты размещения (день недели, месяц, год);
# - [x]  выполнено задание: "Посчитайте среднюю цену одного квадратного метра в 10 населённых пунктах с наибольшим числом объявлений. Выделите населённые пункты с самой высокой и низкой стоимостью квадратного метра. Эти данные можно найти по имени в столбце `locality_name`."
# - [x]  выполнено задание: "Ранее вы посчитали расстояние до центра в километрах. Теперь выделите квартиры в Санкт-Петербурге с помощью столбца `locality_name` и вычислите среднюю цену каждого километра. Опишите, как стоимость объектов зависит от расстояния до центра города."
# - [x]  в каждом этапе есть промежуточные выводы
# - [x]  есть общий вывод
